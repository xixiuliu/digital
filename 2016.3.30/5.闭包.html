<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script type="text/javascript">
		//闭包的特性:内部函数还未执行完,外部函数就不会被销毁
		function outFun(){
			var num = 10;
			function inFun(){
				console.log(num);
			}
			return inFun;
		}
		outFun()();
		// var fn = outFun();
		// fn();

		//javaScript语言,在函数内部可以直接读取全局变量
		// var num = 100;
		// function fun1(){
		// 	console.log(num);
		// }
		// fun1();

		//但是在函数外部就不可以读取函数内部变量
		// function fun1(){
		// 	var n = 100;//如果不加var,那么n就是全局变量
		// }
		// console.log(fun1());//结果是undefined;

		//从外部读取局部变量.
		// function fun3(){
		// 	num1 = 10;
		// 	function fun4(){//此内部函数可以获取其父级的所有局部变量,如num1的值

		// 		console.log(num1);

		// 	}
		// 	//fun4可以读取fun3所有的局部变量,所以只要把fun4作为返回值,就可以在fun3外部读取fun4
		// 	return fun4;
		// }
		// var res = fun3();
		// res();


		//闭包的例子1
// 		var name = "The Window";
// 　　	var object = {
// 　　　　	name : "My Object",
// 　　　　	getNameFunc : function(){
// 　　　　　　	return function(){
// 　　　　　　　　	return this.name;
// 　　　　　		};
// 　　　　	}
// 		};
// 		console.log(object.getNameFunc()());


		//例子2:
		// function outerFun(){
		// 	var a=0;
		// 	function innerFun(){
		// 	    a++;
		// 	    console.log(a);
		// 	}
		// 	return innerFun;  //注意这里
		// }
		// var obj=outerFun();
		// obj();  //结果为1
		// obj();  //结果为2
		// var obj2=outerFun();
		// obj2();  //结果为1
		// obj2();  //结果为2
		//当内部函数在定义它的作用域的外部被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们.

		//例子3:
		// function outerFun(){
		// 	 var a =0;
		// 	 console.log(a);
		// }
		// 	var a=4;
		// 	outerFun();
		// 	console.log(a);

		//例子4:
		//因为没有使用var关键字,因此赋值操作会沿着作用域链到var a=4;  并改变其值.
		// function outerFun(){
		// 	a =0;//没有var
		// 	console.log(a);
		// }
		// 	var a=4;
		// 	outerFun();
		// 	console.log(a);


	</script>
</body>
</html>